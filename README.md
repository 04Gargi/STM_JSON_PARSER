# STM_JSON_PARSER

Description

STM_JSON_PARSER is a simple, lightweight JSON parser designed for embedded systems using C. This parser handles JSON data by tokenizing input strings, parsing the tokens, and then storing the parsed data in a structured format. The project demonstrates how to parse and manipulate JSON data on STM32 or similar embedded platforms where resources (memory and processing power) are limited.

Features:
- Lexical Analysis: The input JSON string is tokenized into basic components such as braces, brackets, commas, colons, strings, numbers, and keywords (`null`, `true`, `false`).
- Syntactic Analysis: The tokens are parsed to construct an in-memory representation of the JSON structure using objects and values.
- Memory Management: The parser handles memory allocation efficiently with dynamic memory allocation used selectively for token appending.
- Extensibility: The parser can be extended to handle more complex data types and more sophisticated error handling.

Files

1. triallib.h  
   This file contains the declarations of the functions, structures, and enums used in the parser. It defines the token types, value types, and structure for both tokens and parsed data.

2. triallib.c 
   This file implements the logic for the parser. It includes functions for:
   - Lexing the input JSON string into tokens.
   - Parsing those tokens to form structured data.
   - Memory management (allocation and deallocation).

 How It Works

 Lexical Analysis (Lexer)

The `lexer()` function processes an input JSON string and breaks it down into tokens. Each token is categorized based on its type (e.g., string, number, object, etc.). The lexer iterates through the input string, handling different characters, and appending corresponding tokens to an array. For example:
- Curly braces `{}` and square brackets `[]` are recognized as object and array boundaries.
- Colons `:` separate keys and values in JSON objects.
- Strings are enclosed in double quotes `"`.
- Numbers, booleans, and `null` are parsed based on their respective formats.

 Syntactic Analysis (Parser)

The `parse_json()` function uses the tokens generated by the lexer to create an in-memory representation of the JSON object. The `parse_object()` function parses JSON objects, ensuring the correct syntax (e.g., key-value pairs separated by colons, commas separating multiple key-value pairs).

Each value (string, number, null) is parsed and stored in a union within the `value` structure, depending on its type. The parser is designed to handle basic data types (`string`, `int`, `null`), but it can be easily extended for more complex data types like arrays and nested objects.

 Functions

 `void append_token(token *tokens, int *token_count, token_type type, const char *value)`
- Description: Appends a new token to the list of tokens.
- Parameters:
  - `tokens`: The array of tokens.
  - `token_count`: The current count of tokens.
  - `type`: The type of the token (e.g., `TOKEN_STRING`, `TOKEN_NUMBER`).
  - `value`: The string value associated with the token.

`token* lexer(const char *input, int *token_count)`
- Description: Tokenizes the input JSON string.
- Parameters:
  - `input`: The input JSON string.
  - `token_count`: The number of tokens parsed.
- Returns: An array of tokens.

`value parse_value(token tok)`
- Description: Parses a token and returns its corresponding value.
- Parameters:
  - `tok`: The token to be parsed.
- Returns: A `value` structure containing the parsed value.

 `void parse_object(value *obj, token *tokens, int *token_index)`
- Description: Parses a JSON object from the tokens.
- Parameters:
  - `obj`: The `value` structure to store the parsed object.
  - `tokens`: The array of tokens.
  - `token_index`: The current index in the token array.

`value parse_json(const char *json_string)`
- Description: Parses the entire JSON string and returns the root value.
- Parameters:
  - `json_string`: The JSON string to be parsed.
- Returns: The root `value` structure containing the parsed data.

Installation

1. Clone this repository to your local machine:

   ```
   git clone https://github.com/yourusername/STM_JSON_PARSER.git
   ```

2. Include the `triallib.h` and `triallib.c` files in your project.

3. Compile the project using your preferred C compiler for embedded systems.

Usage

To use the JSON parser in your project:

1. Include the header file `triallib.h` in your source file.
2. Call the `parse_json()` function with a JSON string to parse it.

Example:

```c
#include "triallib.h"

const char *json_string = "{\"name\":\"John\", \"age\":30, \"city\":\"New York\"}";

int main() {
    value result = parse_json(json_string);

    printf("Name: %s\n", result.as_union.string);
    printf("Age: %d\n", result.as_union.integer);
    return 0;
}
```

 Error Handling

- If the input JSON string exceeds the defined `json_limit`, an error message will be displayed, and the program will exit.
- Memory allocation failures will also trigger error messages and cause the program to terminate.
- Syntax errors in the JSON structure (such as missing colons or unmatched braces) will be reported with appropriate error messages.

Optimizations

- Memory Management: The parser uses dynamic memory allocation for token storage and value parsing, ensuring that memory is efficiently managed. However, excessive memory fragmentation may occur in long-running embedded applications. Consider using static memory allocation or memory pools for optimized performance in resource-constrained environments.

Limitations

- This parser only supports basic JSON structures (objects and simple values such as strings, numbers, and null).
- It does not handle advanced features like JSON arrays or nested objects, but these features can be added with further development.

